╔═══════════════════════════════════════════════════════════════╗
║        ПРОБЛЕМА ЗАВИСАНИЯ ПОСЛЕ ПОДКЛЮЧЕНИЯ - ИСПРАВЛЕНО      ║
╚═══════════════════════════════════════════════════════════════╝

ЧТО БЫЛО:
═══════════════════════════════════════════════════════════════

❌ После успешного подключения к телефону приложение ЗАВИСАЛО
❌ Программа закрывалась (crash)
❌ UI поток блокировался


ПРИЧИНА (ИЗ ЛОГОВ):
═══════════════════════════════════════════════════════════════

Session_20251014_225011/main.log, строка 189:

  [22:51:23.927] [  DEBUG] [WinAPI] API CALL: recv(socket=0x70c, ...)
  
  ← На этом лог ОБРЫВАЕТСЯ!

АНАЛИЗ:

1. ✓ Подключение установлено успешно (22:51:23.826)
2. ✓ BluetoothReceiver начал слушать входящие данные
3. ✗ recv() ЗАБЛОКИРОВАЛ главный поток Qt UI!
4. ✗ UI замер
5. ✗ Приложение зависло и закрылось


ТЕХНИЧЕСКАЯ СУТЬ ПРОБЛЕМЫ:
═══════════════════════════════════════════════════════════════

recv() в БЛОКИРУЮЩЕМ режиме:

  int recv(SOCKET socket, char* buffer, int len, int flags);
  
  • Если flags = 0 (по умолчанию):
    → recv() ЖДЕТ данных БЕСКОНЕЧНО
    → БЛОКИРУЕТ поток выполнения
    → В Qt UI потоке это = ЗАВИСАНИЕ!

Что происходило:

  1. BluetoothReceiver::startListening() запускает QTimer
  2. Каждые 100ms вызывается checkForIncomingData()
  3. checkForIncomingData() вызывает receiveData()
  4. receiveData() вызывает recv(socket, buffer, 4096, 0)
  5. recv() БЛОКИРУЕТСЯ в ожидании данных
  6. UI поток ЗАМИРАЕТ
  7. Qt watchdog убивает процесс → CRASH


РЕШЕНИЕ:
═══════════════════════════════════════════════════════════════

✅ НЕБЛОКИРУЮЩИЙ РЕЖИМ СОКЕТА!

После успешного connect() добавлен код:

  // КРИТИЧНО: Делаем сокет НЕБЛОКИРУЮЩИМ
  u_long nonBlocking = 1;  // 1 = неблокирующий
  ioctlsocket(btSocket, FIONBIO, &nonBlocking);

ЭФФЕКТ:

• recv() БОЛЬШЕ НЕ БЛОКИРУЕТ поток!
• Если данных нет → recv() СРАЗУ вернет WSAEWOULDBLOCK (10035)
• UI остается отзывчивым
• Приложение НЕ ЗАВИСАЕТ!


ЧТО ИЗМЕНИЛОСЬ В КОДЕ:
═══════════════════════════════════════════════════════════════

1. bluetoothconnection.cpp - connectToDevice():

   ДОБАВЛЕНО после успешного connect():
   
   ┌─────────────────────────────────────────────────────────┐
   │ // Делаем сокет НЕБЛОКИРУЮЩИМ                           │
   │ u_long nonBlocking = 1;                                 │
   │ int result = ioctlsocket(btSocket, FIONBIO,            │
   │                          &nonBlocking);                 │
   │                                                         │
   │ if (result == SOCKET_ERROR) {                          │
   │     logger->warning("Не удалось установить             │
   │                      неблокирующий режим!");            │
   │ } else {                                               │
   │     logger->success("✓ Сокет переведен в               │
   │                      НЕБЛОКИРУЮЩИЙ режим");             │
   │ }                                                      │
   └─────────────────────────────────────────────────────────┘

2. bluetoothconnection.cpp - receiveData():

   ДОБАВЛЕНА обработка WSAEWOULDBLOCK:
   
   ┌─────────────────────────────────────────────────────────┐
   │ if (bytesReceived == SOCKET_ERROR) {                   │
   │     int error = WSAGetLastError();                     │
   │                                                         │
   │     // WSAEWOULDBLOCK - это НОРМАЛЬНО!                │
   │     if (error == WSAEWOULDBLOCK || error == 10035) {  │
   │         // Данных пока нет - возвращаем пустой массив │
   │         return QByteArray();                           │
   │     }                                                  │
   │                                                         │
   │     // Реальная ошибка                                │
   │     logger->error("Ошибка приема");                    │
   │     return QByteArray();                               │
   │ }                                                      │
   └─────────────────────────────────────────────────────────┘

3. Уменьшено логирование:

   • recv() НЕ логируется каждый раз (было 10 раз/сек!)
   • Логируется ТОЛЬКО когда получены данные
   • api_calls.log больше не засоряется


КАК ЭТО РАБОТАЕТ ТЕПЕРЬ:
═══════════════════════════════════════════════════════════════

БЛОКИРУЮЩИЙ режим (БЫЛО):

  recv() → ЖДУ ДАННЫЕ... → ЖДУ... → ЖДУ... → ЖДУ... → [UI ЗАМЕР]

НЕБЛОКИРУЮЩИЙ режим (СЕЙЧАС):

  recv() → Данных нет? → Сразу вернуть WSAEWOULDBLOCK → OK
  recv() → Данных нет? → Сразу вернуть WSAEWOULDBLOCK → OK
  recv() → Данных нет? → Сразу вернуть WSAEWOULDBLOCK → OK
  recv() → Есть данные! → Вернуть QByteArray(data) → ✓
  
  UI РАБОТАЕТ ВСЁ ВРЕМЯ! ✓


ЧТО В НОВЫХ ЛОГАХ:
═══════════════════════════════════════════════════════════════

После пересборки в connect.log будет:

  [22:51:23.826] [SUCCESS] ✓✓✓ ПОДКЛЮЧЕНИЕ УСПЕШНО! ✓✓✓
  [22:51:23.827] [SUCCESS] ✓ Сокет переведен в НЕБЛОКИРУЮЩИЙ режим
  [22:51:23.827] [  DEBUG] recv() не будет блокировать UI поток
  
В api_calls.log:

  • НЕ БУДЕТ тысяч записей "API CALL: recv()"
  • Только когда ДЕЙСТВИТЕЛЬНО получены данные


СБОРКА И ТЕСТ:
═══════════════════════════════════════════════════════════════

1. ПЕРЕСОБЕРИТЕ:

   cd C:\QT_projects\IIvuim
   qmake IIvuim.pro
   mingw32-make

2. ЗАПУСТИТЕ Lab6

3. ПОДКЛЮЧИТЕСЬ к телефону:
   
   → Сканировать
   → Выбрать устройство
   → Нажать "Подключить"
   → Ждать...
   
   ✓ После "ПОДКЛЮЧЕНИЕ УСПЕШНО!" приложение НЕ ЗАВИСНЕТ!
   ✓ UI остается отзывчивым!
   ✓ Можно работать дальше!

4. ПРОВЕРЬТЕ ЛОГИ:

   В новой сессии должна быть строка:
   
   "✓ Сокет переведен в НЕБЛОКИРУЮЩИЙ режим"


ТЕХНИЧЕСКИЕ ДЕТАЛИ:
═══════════════════════════════════════════════════════════════

ioctlsocket(socket, FIONBIO, &mode):

  • FIONBIO = File IO Non-Blocking IO
  • mode = 1 → Неблокирующий режим
  • mode = 0 → Блокирующий режим (по умолчанию)

Коды ошибок recv():

  • WSAEWOULDBLOCK (10035) - Нет данных (OK в неблок. режиме)
  • WSAECONNRESET (10054) - Соединение сброшено
  • WSAETIMEDOUT (10060) - Таймаут
  • 0 - Соединение закрыто удаленной стороной

АНАЛОГИЯ:

  Блокирующий recv():
    "Позвони мне когда будет ответ. Я буду ЖДАТЬ у телефона."
    → Ты замер, ничего не делаешь
  
  Неблокирующий recv():
    "Есть ответ? Нет? Ок, займусь другими делами. Спрошу позже."
    → Ты работаешь, проверяешь периодически


ИТОГ:
═══════════════════════════════════════════════════════════════

✅ Проблема зависания ИСПРАВЛЕНА
✅ Сокет теперь НЕБЛОКИРУЮЩИЙ
✅ UI остается отзывчивым
✅ recv() не замораживает поток
✅ Приложение НЕ крашится
✅ Логи не засоряются

ПЕРЕСОБЕРИТЕ И ПОПРОБУЙТЕ! 🚀

Теперь после подключения все будет работать гладко!


